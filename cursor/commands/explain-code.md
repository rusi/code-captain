# Explain Code Command

## Purpose

The `explain-code` command provides comprehensive, AI-powered explanations of code segments, functions, classes, or entire files. It combines natural language explanations with visual diagrams to help developers understand complex code quickly and thoroughly.

## Command Syntax

```bash
cc: explain-code [target]
```

## Parameters

### Target (Required)

- `[function-name]` - Specific function to explain
- `[class-name]` - Entire class explanation
- `[file-path]` - Explain entire file
- `[line-range]` - Explain specific lines (e.g., "125-150")
- `current-selection` - Explain currently selected code in IDE

The command automatically:

- Includes visual diagrams (flowcharts, sequence diagrams, class diagrams)
- Uses intermediate complexity level (technical but accessible)
- Provides full context (includes dependencies and related components)
- Saves explanations to `.code-captain/explanations/` for future reference

## Examples

```bash
# Explain a specific function
cc: explain-code calculateUserDiscount

# Explain a class
cc: explain-code PaymentProcessor

# Explain entire file
cc: explain-code src/auth/AuthService.js

# Explain specific line range
cc: explain-code "src/utils/helpers.js:45-78"

# Explain currently selected code in IDE
cc: explain-code current-selection
```

## Output Structure

All explanations are displayed in chat and automatically saved to `.code-captain/explanations/`

### Chat Display

```
üìã Function Overview
‚îú‚îÄ‚îÄ Purpose: What this code does
‚îú‚îÄ‚îÄ Parameters: Input expectations
‚îú‚îÄ‚îÄ Return Value: What it outputs
‚îú‚îÄ‚îÄ Key Logic: Step-by-step breakdown
‚îî‚îÄ‚îÄ Usage Examples: How to call it

üîÑ Execution Flow
‚îú‚îÄ‚îÄ [Flowchart diagram showing decision paths]
‚îú‚îÄ‚îÄ Decision points and branches
‚îú‚îÄ‚îÄ Error handling paths
‚îî‚îÄ‚îÄ Performance characteristics

üèóÔ∏è Architecture Context
‚îú‚îÄ‚îÄ Where this fits in the system
‚îú‚îÄ‚îÄ Dependencies and related components
‚îú‚îÄ‚îÄ Design patterns used
‚îî‚îÄ‚îÄ Integration points

‚ö° Technical Details
‚îú‚îÄ‚îÄ Time complexity
‚îú‚îÄ‚îÄ Memory usage
‚îú‚îÄ‚îÄ Potential issues
‚îî‚îÄ‚îÄ Optimization opportunities
```

### Saved Format

````markdown
# Code Explanation: [Target Name]

_Generated on [DATE]_

## Overview

[Natural language summary]

## Execution Flow

```mermaid
[Generated diagram]
```
````

## Detailed Breakdown

[Step-by-step explanation]

## Architecture Context

[How it fits in the system]

## Usage Examples

[Code examples]

## Related Components

[Links to other explanations]

---

_Generated by Code Captain on [timestamp]_
_Last updated: [timestamp]_

```

## File Organization

Saved explanations are stored with date prefixes for chronological organization:

```

.code-captain/
‚îî‚îÄ‚îÄ explanations/
‚îú‚îÄ‚îÄ 2024-01-15-AuthenticationFlow.md
‚îú‚îÄ‚îÄ 2024-01-16-PaymentProcessor.md
‚îú‚îÄ‚îÄ 2024-01-16-UserService.md
‚îî‚îÄ‚îÄ 2024-01-17-SearchAlgorithm.md

````

Files are named using the format: `[DATE]-[target-name].md` where DATE is YYYY-MM-DD format.

## Auto-Save Behavior

All explanations are automatically saved to `.code-captain/explanations/` using the format `[DATE]-[target-name].md`. The system uses the same date determination process as the research command to ensure consistent timestamps.

## Date Determination Process

### Primary Method: File System Timestamp

1. **CREATE** directory if not exists: `.code-captain/explanations/`
2. **CREATE** temporary file: `.code-captain/explanations/.date-check`
3. **READ** file creation timestamp from filesystem
4. **EXTRACT** date in YYYY-MM-DD format
5. **DELETE** temporary file
6. **STORE** date in variable for file naming

### Fallback Method: User Confirmation

If file system method fails:

1. **STATE**: "I need to confirm today's date for the explanation file"
2. **ASK**: "What is today's date? (YYYY-MM-DD format)"
3. **WAIT** for user response
4. **VALIDATE** format matches `^\d{4}-\d{2}-\d{2}$`
5. **STORE** date for file naming

**Example filename:** `.code-captain/explanations/2024-01-15-AuthenticationFlow.md`

## Integration Points

### With Other Commands
```bash
# Saved explanations can be referenced by other commands
cc: research authentication
cc: create-spec payment-processing
cc: execute-task "optimize the user search"

# AI can access saved explanations from .code-captain/explanations/
# to provide better context for other commands
```

### With IDE Integration

- Hover over function calls to see saved explanations
- Right-click context menu: "Explain with Code Captain"
- Inline explanation widgets for complex code blocks

## Management Commands

```bash
# List all saved explanations
cc: list-explanations

# Search explanations
cc: search-explanations "authentication"

# Show explanation history
cc: explanation-history calculateDiscount

# Update outdated explanations when code changes
cc: refresh-explanations --check-code-changes
```

## Diagram Types Generated

### Flowcharts

- Control flow through functions
- Decision trees for complex logic
- Error handling paths

### Sequence Diagrams

- Function call sequences
- API interaction flows
- Database transaction flows

### Class Diagrams

- Object relationships
- Inheritance hierarchies
- Dependency structures

### Architecture Diagrams

- Component interactions
- Data flow through system
- Service communication patterns

## Output Characteristics

All explanations use a consistent intermediate technical level that balances accessibility with depth:

- **Technical but accessible**: Explains how the code works with some optimization details
- **Full context**: Always includes related functions, dependencies, and architectural context
- **Visual diagrams**: Every explanation includes appropriate flowcharts, sequence diagrams, or class diagrams
- **Comprehensive coverage**: Shows how the code fits in the entire system

## AI Processing Workflow

1. **Code Analysis**: Parse syntax, identify patterns, measure complexity
2. **Context Gathering**: Understand surrounding code and dependencies
3. **Explanation Generation**: Create intermediate-level natural language description
4. **Diagram Creation**: Generate appropriate visual representations (flowcharts, sequence, class diagrams)
5. **Formatting**: Structure output for both chat display and markdown file
6. **Auto-Save**: Save explanation to `.code-captain/explanations/` with date-prefixed filename `[DATE]-[target-name].md`

## Error Handling

### Common Issues

- **Code not found**: "Could not locate [target]. Please check the path/name."
- **Too complex**: "This code is very complex. Consider breaking into smaller explanations."
- **Limited context**: "Some context may be missing. Ensure related files are accessible."

### Fallback Behaviors

- If diagrams fail to generate, provide text-based flow description
- If target is ambiguous, offer multiple options to choose from
- If code is too large, suggest breaking into smaller segments

## Success Metrics

Track effectiveness through:

- Explanation clarity ratings from users
- Frequency of re-explanations for same code
- Time saved in code reviews and onboarding
- Reduction in "what does this do?" questions during development

## Future Enhancements

### Planned Features

- Interactive explanations with expandable sections
- Voice-generated explanations for accessibility
- Integration with code review tools
- Automatic explanation updates when code changes
- Explanation versioning and history tracking

### Advanced Capabilities

- Performance profiling integration
- Security vulnerability highlighting in explanations
- Code quality suggestions as part of explanations
- Integration with documentation generation tools

```

```
````
